'''
实验报告


实验6  算法的实现（二）
实验报告
1.实验目的
（1）掌握排序算法的基本思想，会用Python去实现一个排序算法。
（2）掌握背包类的动态规划问题的基本思想和方法，能够分析简单的状态转移方程。
（3）掌握用程序去解决搜索类问题的基本方法，学习深度优先搜索和广度优先搜索的基本原理和过程。
2.实验步骤（详述每一个子实验的关键语法及其实现）
2.1 实验任务6-1
用到sorted函数
2.2 实验任务6-2
Load[a][b]的使用，是在b中加入a，但是不要超出b的大小，print("物品是否装入背包的状态:",x[1:])显示有哪些物品被装入。
2.3 实验任务6-3
就是要一个一个的省来试，看是否与前一个地图的颜色重复，若与相邻的颜色重复，则换一个颜色。
3.实验总结
第一个实验不知道是不是方法不对还是本身就简单，感觉很水。第二个实验比较难，第三个实验要比第二个实验简单一些，实在不行就是一个一个地试。
4.简答题
1)请查阅资料，除了你在实验任务6-1中所使用的排序算法外，还有哪些被广泛应用的排序算法？
2)查阅资料，了解完全背包和0-1背包问题在条件限制上有什么区别？（有兴趣的同学可以尝试用Python实验完全背包的解法）
冒泡排序（Bubble sort）
插入排序（Insert sort）
希尔排序（Shell sort）
归并排序（Merge sort）
堆排序
快速排序
实验得分：未评分

问题 1:  排序
'''
# -*- encoding: utf-8 -*-

# please input your code here.
a=[(2,"一月"),(5,"二月"),(12,"三月"),(20,"四月"),(26,"五月"),(30,"六月"),(31,"七月"),(30,"八月"),(26,"九月"),(19,"十月"),(10,"十一月"),(3,"十二月")]
b=[(-9,"一月"),(-6,"二月"),(0,"三月"),(8,"四月"),(14,"五月"),(19,"六月"),(22,"七月"),(21,"八月"),(15,"九月"),(8,"十月"),(0,"十一月"),(-6,"十二月")]
c=[(3,"一月"),(6,"二月"),(9,"三月"),(22,"四月"),(36,"五月"),(74,"六月"),(179,"七月"),(177,"八月"),(53,"九月"),(23,"十月"),(8,"十一月"),(2,"十二月")]
for i in sorted(a):
	print("日均最高气温(单位:℃):",i)
print(" ")
for i in sorted(b):
	print("日均最低气温(单位:℃):",i)
print(" ")
for i in sorted(c):
	print("平均降水量(单位:mm):",i)
# 问题 2:  0-1背包
# -*- encoding: utf-8 -*-

# please input your code here.
def zeroOneknapsack(w, p, n, m):
	#计算Load[i][j]
	for i in range(1, n + 1):
		for j in range(1, m + 1):
			Load[i][j] = Load[i - 1][j]
			if (j >= w[i]) and (Load[i - 1][j - w[i]] + p[i] > Load[i - 1][j]):
				Load[i][j] = Load[i - 1][j - w[i]] + p[i]
	j = m                # 递推装入背包的物体
	for i in range(n, 0, -1):
		if Load[i][j] > Load[i - 1][j]:
			x[i] = "装入"
			j = j - w[i]
	return Load[n][m]               # 返回最大价值
m=10
w=[0,2,2,6,5,4]
p=[0,6,3,5,4,6]
n=len(w)-1                     # 计算n的个数
# 初始化x列表，该列表表示每个物品是否装入背包的状态，初始状态的时候为“未装”
x=["未装" for raw in range(n+1)]
#Load[i][j]表示在前i个物体中，能够装入载重量为j的背包中的物体的最大价值
Load=[[0 for col in range(m + 1)] for raw in range(n + 1)]
# 输出结果
print("装入背包中物品的总价值:",zeroOneknapsack(w, p, n, m))
print("物品是否装入背包的状态:",x[1:])
# 问题 3:  地图着色
# -*- encoding: utf-8 -*-

# please input your code here.
def f(M):
    Color=[-1 for i in range(len(M))]
    n=1
    m=1
    #染色第一个区域，先设置为1
    while m<=len(M):
        while n<=4 and m<=len(M):
            flag=True
            for i in range(m-1):
                if M[m-1][i]==1 and Color[i]==n:
                    flag=False
                    n+=1
            if flag:
                Color[m-1]=n;
                m+=1
                n=1
        if n>4:
            m-=1
            n=Color[m-1]+1
    return Color
print(f([[0,1,0,0,0,0,1],
         [1,0,1,1,1,1,1],
         [0,1,0,1,0,0,0],
         [0,1,1,0,1,0,0],
         [0,1,0,1,0,1,0],
         [0,1,0,0,1,0,1],
         [1,1,0,0,0,1,0]]))